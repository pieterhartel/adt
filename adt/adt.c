/* FILE GENERATED BY ADT, DO NOT EDIT */

#include "primitive.h"

#include "adt.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
void fatal( int dummy, char *s, ... ) {
	va_list a ;
	va_start( a, s ) ;
	vfprintf( stderr, s, a ) ;
	fprintf( stderr, "\n" ) ;
	abort() ;
	va_end( a ) ;
}

char *nametable [] = {
	"input_BIND", "INPUT", 
	"body_BIND", "BODY", 
	"def_BIND", "DEF", 
	"adt_BIND", "ADT", 
	"sum_BIND", "SUM", 
	"summand_BIND", "SUMMAND", 
	"product_BIND", "PRODUCT", 
	"factor_BIND", "FACTOR", 
	"ident_BIND", "IDENT", 
	NULL } ;
static int cnt = 1 ;
extern int lineno ;
extern int charno ;
extern char *filename ;

void __adterr__ ( void *p, int tg, int tg2, char *name ) {
	if( tg < nametablelength ) {
		fatal( 0, "%s: Corrupt tag: %p, %s found, %s expected", name, (void*)p, nametable[tg], nametable[tg2] ) ;
	} else {
		fatal( 0, "%s: Very corrupt tag: %p, %d found, %s expected", name, (void*)p, tg, nametable[tg] ) ;
	}
}

input *bdinput( input **binding ) {
	input *result = calloc( 1, sizeof( struct input_struct ) ) ;
	check_ptr( result, "calloc bdinput" ) ;
	result->tag = input_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frinput( input **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdinput( input **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != input_BIND ) {
			switch( (*subject)->tag ) {
			case INPUT:
				fdstring( &((*subject)->data._INPUT._header) ) ;
				fdbody( &((*subject)->data._INPUT._body) ) ;
				fdstring( &((*subject)->data._INPUT._trailer) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

input *cpinput( input *subject ) {
	input *result = calloc( 1, sizeof( struct input_struct ) ) ;
	check_ptr( result, "calloc cpinput" ) ;
	check_ptr( subject, "cpinput" ) ;
	memcpy( result, subject, sizeof( struct input_struct ) ) ;
	return result ;
}

void mvinput( input *subject, input *object ) {
	check_ptr( subject, "mvinput" ) ;
	check_ptr( object, "mvinput" ) ;
	memcpy( object, subject, sizeof( struct input_struct ) ) ;
}

void prinput( int indent, input *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == input_BIND ) {
			printf( "input_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case INPUT:
				printf( "%s( ", nametable[INPUT] ) ;
				printf( "header=" ) ;
				prstring( indent+1, subject->data._INPUT._header ) ;
				printf( "," ) ;
				printf( "body=" ) ;
				prbody( indent+1, subject->data._INPUT._body ) ;
				printf( "," ) ;
				printf( "trailer=" ) ;
				prstring( indent+1, subject->data._INPUT._trailer ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void clinput( input *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != input_BIND ) {
			switch( subject->tag ) {
			case INPUT:
				clstring( subject->data._INPUT._header ) ;
				clbody( subject->data._INPUT._body ) ;
				clstring( subject->data._INPUT._trailer ) ;
				break ;
			}
		}
	}
}

bool mtinput( input *pattern, input *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == input_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case INPUT:
			return pattern->tag == subject->tag &&
				mtstring( pattern->data._INPUT._header, subject->data._INPUT._header ) &&
				mtbody( pattern->data._INPUT._body, subject->data._INPUT._body ) &&
				mtstring( pattern->data._INPUT._trailer, subject->data._INPUT._trailer ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
input_tag gtinputtag( input *subject ) {
	check_ptr( subject, "gtinputtag" ) ;
	if( subject->tag == input_BIND ) {
		fatal( 0, "gtinputtag" ) ;
	}
	return subject->tag ;
}
#endif

void stinputtag( input *subject, input_tag tag ) {
	check_ptr( subject, "stinputtag" ) ;
	if( tag == input_BIND ) {
		fatal( 0, "stinputtag" ) ;
	}
	subject->tag = tag ;
}

void lfinput( input *subject ) {
	check_ptr( subject, "lfinput" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

input *mkINPUT( string _header, body *_body, string _trailer ) { 
	input *result = calloc( 1, sizeof( struct input_struct ) ) ;
	check_ptr( result, "calloc mkINPUT" ) ;
	result->tag = INPUT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._INPUT._header = _header ;
	result->data._INPUT._body = _body ;
	result->data._INPUT._trailer = _trailer ;
	return result ;
}

input *ptINPUT( string _header, body *_body, string _trailer ) { 
	input *result = calloc( 1, sizeof( struct input_struct ) ) ;
	check_ptr( result, "calloc ptINPUT" ) ;
	result->tag = INPUT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._INPUT._header = _header ;
	result->data._INPUT._body = _body ;
	result->data._INPUT._trailer = _trailer ;
	return result ;
}

string *adINPUTheader( input *subject ) {
	check_tag( subject, INPUT, "adINPUTheader" ) ;
	return &subject->data._INPUT._header ;
}

#ifndef _FAST_
string gtINPUTheader( input *subject ) {
	check_tag( subject, INPUT, "gtINPUTheader" ) ;
	return subject->data._INPUT._header ;
}

#endif

void stINPUTheader( input *subject, string value ) {
	check_tag( subject, INPUT, "stINPUTheader" ) ;
	subject->data._INPUT._header = value ;
}

body **adINPUTbody( input *subject ) {
	check_tag( subject, INPUT, "adINPUTbody" ) ;
	return &subject->data._INPUT._body ;
}

#ifndef _FAST_
body *gtINPUTbody( input *subject ) {
	check_tag( subject, INPUT, "gtINPUTbody" ) ;
	return subject->data._INPUT._body ;
}

#endif

void stINPUTbody( input *subject, body *value ) {
	check_tag( subject, INPUT, "stINPUTbody" ) ;
	subject->data._INPUT._body = value ;
}

string *adINPUTtrailer( input *subject ) {
	check_tag( subject, INPUT, "adINPUTtrailer" ) ;
	return &subject->data._INPUT._trailer ;
}

#ifndef _FAST_
string gtINPUTtrailer( input *subject ) {
	check_tag( subject, INPUT, "gtINPUTtrailer" ) ;
	return subject->data._INPUT._trailer ;
}

#endif

void stINPUTtrailer( input *subject, string value ) {
	check_tag( subject, INPUT, "stINPUTtrailer" ) ;
	subject->data._INPUT._trailer = value ;
}

body *bdbody( body **binding ) {
	body *result = calloc( 1, sizeof( struct body_struct ) ) ;
	check_ptr( result, "calloc bdbody" ) ;
	result->tag = body_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frbody( body **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdbody( body **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != body_BIND ) {
			switch( (*subject)->tag ) {
			case BODY:
				fddef( &((*subject)->data._BODY._def) ) ;
				fdbody( &((*subject)->data._BODY._next) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

body *cpbody( body *subject ) {
	body *result = calloc( 1, sizeof( struct body_struct ) ) ;
	check_ptr( result, "calloc cpbody" ) ;
	check_ptr( subject, "cpbody" ) ;
	memcpy( result, subject, sizeof( struct body_struct ) ) ;
	return result ;
}

void mvbody( body *subject, body *object ) {
	check_ptr( subject, "mvbody" ) ;
	check_ptr( object, "mvbody" ) ;
	memcpy( object, subject, sizeof( struct body_struct ) ) ;
}

void prbody( int indent, body *subject ) {
	printf( "[" ) ;
	while( subject != NULL ) {
		if( subject->flag ) {
			printf( "@%d@", subject->flag ) ;
			break ;
		} else if( subject->tag == body_BIND ) {
			printf( "body_BIND( %p )", (void*)subject->data._binding ) ;
			break ;
		} else {
			subject->flag = cnt++ ;
			printf( "\n%-3d: %*s(", subject->flag, indent, "" ) ;
			printf( "def=" ) ;
			prdef( indent+1, subject->data._BODY._def ) ;
			printf( " )" ) ;
			subject = subject->data._BODY._next ;
			if( subject != NULL ) {
				printf( "," ) ;
			}
		}
	}
	printf( "]" ) ;
}

void clbody( body *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != body_BIND ) {
			switch( subject->tag ) {
			case BODY:
				cldef( subject->data._BODY._def ) ;
				clbody( subject->data._BODY._next ) ;
				break ;
			}
		}
	}
}

bool mtbody( body *pattern, body *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == body_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case BODY:
			return pattern->tag == subject->tag &&
				mtdef( pattern->data._BODY._def, subject->data._BODY._def ) &&
				mtbody( pattern->data._BODY._next, subject->data._BODY._next ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
body_tag gtbodytag( body *subject ) {
	check_ptr( subject, "gtbodytag" ) ;
	if( subject->tag == body_BIND ) {
		fatal( 0, "gtbodytag" ) ;
	}
	return subject->tag ;
}
#endif

void stbodytag( body *subject, body_tag tag ) {
	check_ptr( subject, "stbodytag" ) ;
	if( tag == body_BIND ) {
		fatal( 0, "stbodytag" ) ;
	}
	subject->tag = tag ;
}

void lfbody( body *subject ) {
	check_ptr( subject, "lfbody" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

body *mkBODY( def *_def, body *_next ) { 
	body *result = calloc( 1, sizeof( struct body_struct ) ) ;
	check_ptr( result, "calloc mkBODY" ) ;
	result->tag = BODY ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._BODY._def = _def ;
	result->data._BODY._next = _next ;
	return result ;
}

body *ptBODY( def *_def, body *_next ) { 
	body *result = calloc( 1, sizeof( struct body_struct ) ) ;
	check_ptr( result, "calloc ptBODY" ) ;
	result->tag = BODY ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._BODY._def = _def ;
	result->data._BODY._next = _next ;
	return result ;
}

def **adBODYdef( body *subject ) {
	check_tag( subject, BODY, "adBODYdef" ) ;
	return &subject->data._BODY._def ;
}

#ifndef _FAST_
def *gtBODYdef( body *subject ) {
	check_tag( subject, BODY, "gtBODYdef" ) ;
	return subject->data._BODY._def ;
}

#endif

void stBODYdef( body *subject, def *value ) {
	check_tag( subject, BODY, "stBODYdef" ) ;
	subject->data._BODY._def = value ;
}

body **adBODYnext( body *subject ) {
	check_tag( subject, BODY, "adBODYnext" ) ;
	return &subject->data._BODY._next ;
}

#ifndef _FAST_
body *gtBODYnext( body *subject ) {
	check_tag( subject, BODY, "gtBODYnext" ) ;
	return subject->data._BODY._next ;
}

#endif

void stBODYnext( body *subject, body *value ) {
	check_tag( subject, BODY, "stBODYnext" ) ;
	subject->data._BODY._next = value ;
}

body *apbody( body *subject, body *object ) {
	body *last = NULL ;
	body *curr = subject ;
	while( curr != NULL ) {
		if( curr->tag != BODY ) {
			fatal( 0, "apbody" ) ;
		} else {
			last = curr ;
			curr = curr->data._BODY._next ;
		}
	}
	if( last == NULL ) {
		return object ;
	} else {
		last->data._BODY._next = object ;
		return subject ;
	}
}

void itbody( void ( *f ) ( void *, def *), void *x, body *subject ) {
	while( subject != NULL ) {
		if( subject->tag != BODY ) {
			fatal( 0, "itbody" ) ;
		} else {
			f( x, subject->data._BODY._def ) ;
			subject = subject->data._BODY._next ;
		}
	}
}

def *bddef( def **binding ) {
	def *result = calloc( 1, sizeof( struct def_struct ) ) ;
	check_ptr( result, "calloc bddef" ) ;
	result->tag = def_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frdef( def **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fddef( def **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != def_BIND ) {
			switch( (*subject)->tag ) {
			case DEF:
				fdstring( &((*subject)->data._DEF._comment) ) ;
				fdident( &((*subject)->data._DEF._ident) ) ;
				fdproduct( &((*subject)->data._DEF._product) ) ;
				fdadt( &((*subject)->data._DEF._adt) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

def *cpdef( def *subject ) {
	def *result = calloc( 1, sizeof( struct def_struct ) ) ;
	check_ptr( result, "calloc cpdef" ) ;
	check_ptr( subject, "cpdef" ) ;
	memcpy( result, subject, sizeof( struct def_struct ) ) ;
	return result ;
}

void mvdef( def *subject, def *object ) {
	check_ptr( subject, "mvdef" ) ;
	check_ptr( object, "mvdef" ) ;
	memcpy( object, subject, sizeof( struct def_struct ) ) ;
}

void prdef( int indent, def *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == def_BIND ) {
			printf( "def_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case DEF:
				printf( "%s( ", nametable[DEF] ) ;
				printf( "comment=" ) ;
				prstring( indent+1, subject->data._DEF._comment ) ;
				printf( "," ) ;
				printf( "ident=" ) ;
				prident( indent+1, subject->data._DEF._ident ) ;
				printf( "," ) ;
				printf( "product=" ) ;
				prproduct( indent+1, subject->data._DEF._product ) ;
				printf( "," ) ;
				printf( "adt=" ) ;
				pradt( indent+1, subject->data._DEF._adt ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void cldef( def *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != def_BIND ) {
			switch( subject->tag ) {
			case DEF:
				clstring( subject->data._DEF._comment ) ;
				clident( subject->data._DEF._ident ) ;
				clproduct( subject->data._DEF._product ) ;
				cladt( subject->data._DEF._adt ) ;
				break ;
			}
		}
	}
}

bool mtdef( def *pattern, def *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == def_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case DEF:
			return pattern->tag == subject->tag &&
				mtstring( pattern->data._DEF._comment, subject->data._DEF._comment ) &&
				mtident( pattern->data._DEF._ident, subject->data._DEF._ident ) &&
				mtproduct( pattern->data._DEF._product, subject->data._DEF._product ) &&
				mtadt( pattern->data._DEF._adt, subject->data._DEF._adt ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
def_tag gtdeftag( def *subject ) {
	check_ptr( subject, "gtdeftag" ) ;
	if( subject->tag == def_BIND ) {
		fatal( 0, "gtdeftag" ) ;
	}
	return subject->tag ;
}
#endif

void stdeftag( def *subject, def_tag tag ) {
	check_ptr( subject, "stdeftag" ) ;
	if( tag == def_BIND ) {
		fatal( 0, "stdeftag" ) ;
	}
	subject->tag = tag ;
}

void lfdef( def *subject ) {
	check_ptr( subject, "lfdef" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

def *mkDEF( string _comment, ident *_ident, product *_product, adt *_adt ) { 
	def *result = calloc( 1, sizeof( struct def_struct ) ) ;
	check_ptr( result, "calloc mkDEF" ) ;
	result->tag = DEF ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._DEF._comment = _comment ;
	result->data._DEF._ident = _ident ;
	result->data._DEF._product = _product ;
	result->data._DEF._adt = _adt ;
	return result ;
}

def *ptDEF( string _comment, ident *_ident, product *_product, adt *_adt ) { 
	def *result = calloc( 1, sizeof( struct def_struct ) ) ;
	check_ptr( result, "calloc ptDEF" ) ;
	result->tag = DEF ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._DEF._comment = _comment ;
	result->data._DEF._ident = _ident ;
	result->data._DEF._product = _product ;
	result->data._DEF._adt = _adt ;
	return result ;
}

string *adDEFcomment( def *subject ) {
	check_tag( subject, DEF, "adDEFcomment" ) ;
	return &subject->data._DEF._comment ;
}

#ifndef _FAST_
string gtDEFcomment( def *subject ) {
	check_tag( subject, DEF, "gtDEFcomment" ) ;
	return subject->data._DEF._comment ;
}

#endif

void stDEFcomment( def *subject, string value ) {
	check_tag( subject, DEF, "stDEFcomment" ) ;
	subject->data._DEF._comment = value ;
}

ident **adDEFident( def *subject ) {
	check_tag( subject, DEF, "adDEFident" ) ;
	return &subject->data._DEF._ident ;
}

#ifndef _FAST_
ident *gtDEFident( def *subject ) {
	check_tag( subject, DEF, "gtDEFident" ) ;
	return subject->data._DEF._ident ;
}

#endif

void stDEFident( def *subject, ident *value ) {
	check_tag( subject, DEF, "stDEFident" ) ;
	subject->data._DEF._ident = value ;
}

product **adDEFproduct( def *subject ) {
	check_tag( subject, DEF, "adDEFproduct" ) ;
	return &subject->data._DEF._product ;
}

#ifndef _FAST_
product *gtDEFproduct( def *subject ) {
	check_tag( subject, DEF, "gtDEFproduct" ) ;
	return subject->data._DEF._product ;
}

#endif

void stDEFproduct( def *subject, product *value ) {
	check_tag( subject, DEF, "stDEFproduct" ) ;
	subject->data._DEF._product = value ;
}

adt **adDEFadt( def *subject ) {
	check_tag( subject, DEF, "adDEFadt" ) ;
	return &subject->data._DEF._adt ;
}

#ifndef _FAST_
adt *gtDEFadt( def *subject ) {
	check_tag( subject, DEF, "gtDEFadt" ) ;
	return subject->data._DEF._adt ;
}

#endif

void stDEFadt( def *subject, adt *value ) {
	check_tag( subject, DEF, "stDEFadt" ) ;
	subject->data._DEF._adt = value ;
}

adt *bdadt( adt **binding ) {
	adt *result = calloc( 1, sizeof( struct adt_struct ) ) ;
	check_ptr( result, "calloc bdadt" ) ;
	result->tag = adt_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void fradt( adt **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdadt( adt **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != adt_BIND ) {
			switch( (*subject)->tag ) {
			case ADT:
				fdsum( &((*subject)->data._ADT._sum) ) ;
				fdstring( &((*subject)->data._ADT._class) ) ;
				fdproduct( &((*subject)->data._ADT._parameters) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

adt *cpadt( adt *subject ) {
	adt *result = calloc( 1, sizeof( struct adt_struct ) ) ;
	check_ptr( result, "calloc cpadt" ) ;
	check_ptr( subject, "cpadt" ) ;
	memcpy( result, subject, sizeof( struct adt_struct ) ) ;
	return result ;
}

void mvadt( adt *subject, adt *object ) {
	check_ptr( subject, "mvadt" ) ;
	check_ptr( object, "mvadt" ) ;
	memcpy( object, subject, sizeof( struct adt_struct ) ) ;
}

void pradt( int indent, adt *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == adt_BIND ) {
			printf( "adt_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case ADT:
				printf( "%s( ", nametable[ADT] ) ;
				printf( "sum=" ) ;
				prsum( indent+1, subject->data._ADT._sum ) ;
				printf( "," ) ;
				printf( "class=" ) ;
				prstring( indent+1, subject->data._ADT._class ) ;
				printf( "," ) ;
				printf( "parameters=" ) ;
				prproduct( indent+1, subject->data._ADT._parameters ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void cladt( adt *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != adt_BIND ) {
			switch( subject->tag ) {
			case ADT:
				clsum( subject->data._ADT._sum ) ;
				clstring( subject->data._ADT._class ) ;
				clproduct( subject->data._ADT._parameters ) ;
				break ;
			}
		}
	}
}

bool mtadt( adt *pattern, adt *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == adt_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case ADT:
			return pattern->tag == subject->tag &&
				mtsum( pattern->data._ADT._sum, subject->data._ADT._sum ) &&
				mtstring( pattern->data._ADT._class, subject->data._ADT._class ) &&
				mtproduct( pattern->data._ADT._parameters, subject->data._ADT._parameters ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
adt_tag gtadttag( adt *subject ) {
	check_ptr( subject, "gtadttag" ) ;
	if( subject->tag == adt_BIND ) {
		fatal( 0, "gtadttag" ) ;
	}
	return subject->tag ;
}
#endif

void stadttag( adt *subject, adt_tag tag ) {
	check_ptr( subject, "stadttag" ) ;
	if( tag == adt_BIND ) {
		fatal( 0, "stadttag" ) ;
	}
	subject->tag = tag ;
}

void lfadt( adt *subject ) {
	check_ptr( subject, "lfadt" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

adt *mkADT( sum *_sum, string _class, product *_parameters ) { 
	adt *result = calloc( 1, sizeof( struct adt_struct ) ) ;
	check_ptr( result, "calloc mkADT" ) ;
	result->tag = ADT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._ADT._sum = _sum ;
	result->data._ADT._class = _class ;
	result->data._ADT._parameters = _parameters ;
	return result ;
}

adt *ptADT( sum *_sum, string _class, product *_parameters ) { 
	adt *result = calloc( 1, sizeof( struct adt_struct ) ) ;
	check_ptr( result, "calloc ptADT" ) ;
	result->tag = ADT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._ADT._sum = _sum ;
	result->data._ADT._class = _class ;
	result->data._ADT._parameters = _parameters ;
	return result ;
}

sum **adADTsum( adt *subject ) {
	check_tag( subject, ADT, "adADTsum" ) ;
	return &subject->data._ADT._sum ;
}

#ifndef _FAST_
sum *gtADTsum( adt *subject ) {
	check_tag( subject, ADT, "gtADTsum" ) ;
	return subject->data._ADT._sum ;
}

#endif

void stADTsum( adt *subject, sum *value ) {
	check_tag( subject, ADT, "stADTsum" ) ;
	subject->data._ADT._sum = value ;
}

string *adADTclass( adt *subject ) {
	check_tag( subject, ADT, "adADTclass" ) ;
	return &subject->data._ADT._class ;
}

#ifndef _FAST_
string gtADTclass( adt *subject ) {
	check_tag( subject, ADT, "gtADTclass" ) ;
	return subject->data._ADT._class ;
}

#endif

void stADTclass( adt *subject, string value ) {
	check_tag( subject, ADT, "stADTclass" ) ;
	subject->data._ADT._class = value ;
}

product **adADTparameters( adt *subject ) {
	check_tag( subject, ADT, "adADTparameters" ) ;
	return &subject->data._ADT._parameters ;
}

#ifndef _FAST_
product *gtADTparameters( adt *subject ) {
	check_tag( subject, ADT, "gtADTparameters" ) ;
	return subject->data._ADT._parameters ;
}

#endif

void stADTparameters( adt *subject, product *value ) {
	check_tag( subject, ADT, "stADTparameters" ) ;
	subject->data._ADT._parameters = value ;
}

sum *bdsum( sum **binding ) {
	sum *result = calloc( 1, sizeof( struct sum_struct ) ) ;
	check_ptr( result, "calloc bdsum" ) ;
	result->tag = sum_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frsum( sum **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdsum( sum **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != sum_BIND ) {
			switch( (*subject)->tag ) {
			case SUM:
				fdsummand( &((*subject)->data._SUM._summand) ) ;
				fdsum( &((*subject)->data._SUM._next) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

sum *cpsum( sum *subject ) {
	sum *result = calloc( 1, sizeof( struct sum_struct ) ) ;
	check_ptr( result, "calloc cpsum" ) ;
	check_ptr( subject, "cpsum" ) ;
	memcpy( result, subject, sizeof( struct sum_struct ) ) ;
	return result ;
}

void mvsum( sum *subject, sum *object ) {
	check_ptr( subject, "mvsum" ) ;
	check_ptr( object, "mvsum" ) ;
	memcpy( object, subject, sizeof( struct sum_struct ) ) ;
}

void prsum( int indent, sum *subject ) {
	printf( "[" ) ;
	while( subject != NULL ) {
		if( subject->flag ) {
			printf( "@%d@", subject->flag ) ;
			break ;
		} else if( subject->tag == sum_BIND ) {
			printf( "sum_BIND( %p )", (void*)subject->data._binding ) ;
			break ;
		} else {
			subject->flag = cnt++ ;
			printf( "\n%-3d: %*s(", subject->flag, indent, "" ) ;
			printf( "summand=" ) ;
			prsummand( indent+1, subject->data._SUM._summand ) ;
			printf( " )" ) ;
			subject = subject->data._SUM._next ;
			if( subject != NULL ) {
				printf( "," ) ;
			}
		}
	}
	printf( "]" ) ;
}

void clsum( sum *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != sum_BIND ) {
			switch( subject->tag ) {
			case SUM:
				clsummand( subject->data._SUM._summand ) ;
				clsum( subject->data._SUM._next ) ;
				break ;
			}
		}
	}
}

bool mtsum( sum *pattern, sum *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == sum_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case SUM:
			return pattern->tag == subject->tag &&
				mtsummand( pattern->data._SUM._summand, subject->data._SUM._summand ) &&
				mtsum( pattern->data._SUM._next, subject->data._SUM._next ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
sum_tag gtsumtag( sum *subject ) {
	check_ptr( subject, "gtsumtag" ) ;
	if( subject->tag == sum_BIND ) {
		fatal( 0, "gtsumtag" ) ;
	}
	return subject->tag ;
}
#endif

void stsumtag( sum *subject, sum_tag tag ) {
	check_ptr( subject, "stsumtag" ) ;
	if( tag == sum_BIND ) {
		fatal( 0, "stsumtag" ) ;
	}
	subject->tag = tag ;
}

void lfsum( sum *subject ) {
	check_ptr( subject, "lfsum" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

sum *mkSUM( summand *_summand, sum *_next ) { 
	sum *result = calloc( 1, sizeof( struct sum_struct ) ) ;
	check_ptr( result, "calloc mkSUM" ) ;
	result->tag = SUM ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._SUM._summand = _summand ;
	result->data._SUM._next = _next ;
	return result ;
}

sum *ptSUM( summand *_summand, sum *_next ) { 
	sum *result = calloc( 1, sizeof( struct sum_struct ) ) ;
	check_ptr( result, "calloc ptSUM" ) ;
	result->tag = SUM ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._SUM._summand = _summand ;
	result->data._SUM._next = _next ;
	return result ;
}

summand **adSUMsummand( sum *subject ) {
	check_tag( subject, SUM, "adSUMsummand" ) ;
	return &subject->data._SUM._summand ;
}

#ifndef _FAST_
summand *gtSUMsummand( sum *subject ) {
	check_tag( subject, SUM, "gtSUMsummand" ) ;
	return subject->data._SUM._summand ;
}

#endif

void stSUMsummand( sum *subject, summand *value ) {
	check_tag( subject, SUM, "stSUMsummand" ) ;
	subject->data._SUM._summand = value ;
}

sum **adSUMnext( sum *subject ) {
	check_tag( subject, SUM, "adSUMnext" ) ;
	return &subject->data._SUM._next ;
}

#ifndef _FAST_
sum *gtSUMnext( sum *subject ) {
	check_tag( subject, SUM, "gtSUMnext" ) ;
	return subject->data._SUM._next ;
}

#endif

void stSUMnext( sum *subject, sum *value ) {
	check_tag( subject, SUM, "stSUMnext" ) ;
	subject->data._SUM._next = value ;
}

sum *apsum( sum *subject, sum *object ) {
	sum *last = NULL ;
	sum *curr = subject ;
	while( curr != NULL ) {
		if( curr->tag != SUM ) {
			fatal( 0, "apsum" ) ;
		} else {
			last = curr ;
			curr = curr->data._SUM._next ;
		}
	}
	if( last == NULL ) {
		return object ;
	} else {
		last->data._SUM._next = object ;
		return subject ;
	}
}

void itsum( void ( *f ) ( void *, summand *), void *x, sum *subject ) {
	while( subject != NULL ) {
		if( subject->tag != SUM ) {
			fatal( 0, "itsum" ) ;
		} else {
			f( x, subject->data._SUM._summand ) ;
			subject = subject->data._SUM._next ;
		}
	}
}

summand *bdsummand( summand **binding ) {
	summand *result = calloc( 1, sizeof( struct summand_struct ) ) ;
	check_ptr( result, "calloc bdsummand" ) ;
	result->tag = summand_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frsummand( summand **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdsummand( summand **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != summand_BIND ) {
			switch( (*subject)->tag ) {
			case SUMMAND:
				fdstring( &((*subject)->data._SUMMAND._comment) ) ;
				fdident( &((*subject)->data._SUMMAND._ident) ) ;
				fdproduct( &((*subject)->data._SUMMAND._product) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

summand *cpsummand( summand *subject ) {
	summand *result = calloc( 1, sizeof( struct summand_struct ) ) ;
	check_ptr( result, "calloc cpsummand" ) ;
	check_ptr( subject, "cpsummand" ) ;
	memcpy( result, subject, sizeof( struct summand_struct ) ) ;
	return result ;
}

void mvsummand( summand *subject, summand *object ) {
	check_ptr( subject, "mvsummand" ) ;
	check_ptr( object, "mvsummand" ) ;
	memcpy( object, subject, sizeof( struct summand_struct ) ) ;
}

void prsummand( int indent, summand *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == summand_BIND ) {
			printf( "summand_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case SUMMAND:
				printf( "%s( ", nametable[SUMMAND] ) ;
				printf( "comment=" ) ;
				prstring( indent+1, subject->data._SUMMAND._comment ) ;
				printf( "," ) ;
				printf( "ident=" ) ;
				prident( indent+1, subject->data._SUMMAND._ident ) ;
				printf( "," ) ;
				printf( "product=" ) ;
				prproduct( indent+1, subject->data._SUMMAND._product ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void clsummand( summand *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != summand_BIND ) {
			switch( subject->tag ) {
			case SUMMAND:
				clstring( subject->data._SUMMAND._comment ) ;
				clident( subject->data._SUMMAND._ident ) ;
				clproduct( subject->data._SUMMAND._product ) ;
				break ;
			}
		}
	}
}

bool mtsummand( summand *pattern, summand *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == summand_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case SUMMAND:
			return pattern->tag == subject->tag &&
				mtstring( pattern->data._SUMMAND._comment, subject->data._SUMMAND._comment ) &&
				mtident( pattern->data._SUMMAND._ident, subject->data._SUMMAND._ident ) &&
				mtproduct( pattern->data._SUMMAND._product, subject->data._SUMMAND._product ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
summand_tag gtsummandtag( summand *subject ) {
	check_ptr( subject, "gtsummandtag" ) ;
	if( subject->tag == summand_BIND ) {
		fatal( 0, "gtsummandtag" ) ;
	}
	return subject->tag ;
}
#endif

void stsummandtag( summand *subject, summand_tag tag ) {
	check_ptr( subject, "stsummandtag" ) ;
	if( tag == summand_BIND ) {
		fatal( 0, "stsummandtag" ) ;
	}
	subject->tag = tag ;
}

void lfsummand( summand *subject ) {
	check_ptr( subject, "lfsummand" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

summand *mkSUMMAND( string _comment, ident *_ident, product *_product ) { 
	summand *result = calloc( 1, sizeof( struct summand_struct ) ) ;
	check_ptr( result, "calloc mkSUMMAND" ) ;
	result->tag = SUMMAND ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._SUMMAND._comment = _comment ;
	result->data._SUMMAND._ident = _ident ;
	result->data._SUMMAND._product = _product ;
	return result ;
}

summand *ptSUMMAND( string _comment, ident *_ident, product *_product ) { 
	summand *result = calloc( 1, sizeof( struct summand_struct ) ) ;
	check_ptr( result, "calloc ptSUMMAND" ) ;
	result->tag = SUMMAND ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._SUMMAND._comment = _comment ;
	result->data._SUMMAND._ident = _ident ;
	result->data._SUMMAND._product = _product ;
	return result ;
}

string *adSUMMANDcomment( summand *subject ) {
	check_tag( subject, SUMMAND, "adSUMMANDcomment" ) ;
	return &subject->data._SUMMAND._comment ;
}

#ifndef _FAST_
string gtSUMMANDcomment( summand *subject ) {
	check_tag( subject, SUMMAND, "gtSUMMANDcomment" ) ;
	return subject->data._SUMMAND._comment ;
}

#endif

void stSUMMANDcomment( summand *subject, string value ) {
	check_tag( subject, SUMMAND, "stSUMMANDcomment" ) ;
	subject->data._SUMMAND._comment = value ;
}

ident **adSUMMANDident( summand *subject ) {
	check_tag( subject, SUMMAND, "adSUMMANDident" ) ;
	return &subject->data._SUMMAND._ident ;
}

#ifndef _FAST_
ident *gtSUMMANDident( summand *subject ) {
	check_tag( subject, SUMMAND, "gtSUMMANDident" ) ;
	return subject->data._SUMMAND._ident ;
}

#endif

void stSUMMANDident( summand *subject, ident *value ) {
	check_tag( subject, SUMMAND, "stSUMMANDident" ) ;
	subject->data._SUMMAND._ident = value ;
}

product **adSUMMANDproduct( summand *subject ) {
	check_tag( subject, SUMMAND, "adSUMMANDproduct" ) ;
	return &subject->data._SUMMAND._product ;
}

#ifndef _FAST_
product *gtSUMMANDproduct( summand *subject ) {
	check_tag( subject, SUMMAND, "gtSUMMANDproduct" ) ;
	return subject->data._SUMMAND._product ;
}

#endif

void stSUMMANDproduct( summand *subject, product *value ) {
	check_tag( subject, SUMMAND, "stSUMMANDproduct" ) ;
	subject->data._SUMMAND._product = value ;
}

product *bdproduct( product **binding ) {
	product *result = calloc( 1, sizeof( struct product_struct ) ) ;
	check_ptr( result, "calloc bdproduct" ) ;
	result->tag = product_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frproduct( product **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdproduct( product **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != product_BIND ) {
			switch( (*subject)->tag ) {
			case PRODUCT:
				fdfactor( &((*subject)->data._PRODUCT._factor) ) ;
				fdproduct( &((*subject)->data._PRODUCT._next) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

product *cpproduct( product *subject ) {
	product *result = calloc( 1, sizeof( struct product_struct ) ) ;
	check_ptr( result, "calloc cpproduct" ) ;
	check_ptr( subject, "cpproduct" ) ;
	memcpy( result, subject, sizeof( struct product_struct ) ) ;
	return result ;
}

void mvproduct( product *subject, product *object ) {
	check_ptr( subject, "mvproduct" ) ;
	check_ptr( object, "mvproduct" ) ;
	memcpy( object, subject, sizeof( struct product_struct ) ) ;
}

void prproduct( int indent, product *subject ) {
	printf( "[" ) ;
	while( subject != NULL ) {
		if( subject->flag ) {
			printf( "@%d@", subject->flag ) ;
			break ;
		} else if( subject->tag == product_BIND ) {
			printf( "product_BIND( %p )", (void*)subject->data._binding ) ;
			break ;
		} else {
			subject->flag = cnt++ ;
			printf( "\n%-3d: %*s(", subject->flag, indent, "" ) ;
			printf( "factor=" ) ;
			prfactor( indent+1, subject->data._PRODUCT._factor ) ;
			printf( " )" ) ;
			subject = subject->data._PRODUCT._next ;
			if( subject != NULL ) {
				printf( "," ) ;
			}
		}
	}
	printf( "]" ) ;
}

void clproduct( product *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != product_BIND ) {
			switch( subject->tag ) {
			case PRODUCT:
				clfactor( subject->data._PRODUCT._factor ) ;
				clproduct( subject->data._PRODUCT._next ) ;
				break ;
			}
		}
	}
}

bool mtproduct( product *pattern, product *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == product_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case PRODUCT:
			return pattern->tag == subject->tag &&
				mtfactor( pattern->data._PRODUCT._factor, subject->data._PRODUCT._factor ) &&
				mtproduct( pattern->data._PRODUCT._next, subject->data._PRODUCT._next ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
product_tag gtproducttag( product *subject ) {
	check_ptr( subject, "gtproducttag" ) ;
	if( subject->tag == product_BIND ) {
		fatal( 0, "gtproducttag" ) ;
	}
	return subject->tag ;
}
#endif

void stproducttag( product *subject, product_tag tag ) {
	check_ptr( subject, "stproducttag" ) ;
	if( tag == product_BIND ) {
		fatal( 0, "stproducttag" ) ;
	}
	subject->tag = tag ;
}

void lfproduct( product *subject ) {
	check_ptr( subject, "lfproduct" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

product *mkPRODUCT( factor *_factor, product *_next ) { 
	product *result = calloc( 1, sizeof( struct product_struct ) ) ;
	check_ptr( result, "calloc mkPRODUCT" ) ;
	result->tag = PRODUCT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._PRODUCT._factor = _factor ;
	result->data._PRODUCT._next = _next ;
	return result ;
}

product *ptPRODUCT( factor *_factor, product *_next ) { 
	product *result = calloc( 1, sizeof( struct product_struct ) ) ;
	check_ptr( result, "calloc ptPRODUCT" ) ;
	result->tag = PRODUCT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._PRODUCT._factor = _factor ;
	result->data._PRODUCT._next = _next ;
	return result ;
}

factor **adPRODUCTfactor( product *subject ) {
	check_tag( subject, PRODUCT, "adPRODUCTfactor" ) ;
	return &subject->data._PRODUCT._factor ;
}

#ifndef _FAST_
factor *gtPRODUCTfactor( product *subject ) {
	check_tag( subject, PRODUCT, "gtPRODUCTfactor" ) ;
	return subject->data._PRODUCT._factor ;
}

#endif

void stPRODUCTfactor( product *subject, factor *value ) {
	check_tag( subject, PRODUCT, "stPRODUCTfactor" ) ;
	subject->data._PRODUCT._factor = value ;
}

product **adPRODUCTnext( product *subject ) {
	check_tag( subject, PRODUCT, "adPRODUCTnext" ) ;
	return &subject->data._PRODUCT._next ;
}

#ifndef _FAST_
product *gtPRODUCTnext( product *subject ) {
	check_tag( subject, PRODUCT, "gtPRODUCTnext" ) ;
	return subject->data._PRODUCT._next ;
}

#endif

void stPRODUCTnext( product *subject, product *value ) {
	check_tag( subject, PRODUCT, "stPRODUCTnext" ) ;
	subject->data._PRODUCT._next = value ;
}

product *approduct( product *subject, product *object ) {
	product *last = NULL ;
	product *curr = subject ;
	while( curr != NULL ) {
		if( curr->tag != PRODUCT ) {
			fatal( 0, "approduct" ) ;
		} else {
			last = curr ;
			curr = curr->data._PRODUCT._next ;
		}
	}
	if( last == NULL ) {
		return object ;
	} else {
		last->data._PRODUCT._next = object ;
		return subject ;
	}
}

void itproduct( void ( *f ) ( void *, factor *), void *x, product *subject ) {
	while( subject != NULL ) {
		if( subject->tag != PRODUCT ) {
			fatal( 0, "itproduct" ) ;
		} else {
			f( x, subject->data._PRODUCT._factor ) ;
			subject = subject->data._PRODUCT._next ;
		}
	}
}

factor *bdfactor( factor **binding ) {
	factor *result = calloc( 1, sizeof( struct factor_struct ) ) ;
	check_ptr( result, "calloc bdfactor" ) ;
	result->tag = factor_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frfactor( factor **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdfactor( factor **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != factor_BIND ) {
			switch( (*subject)->tag ) {
			case FACTOR:
				fdstring( &((*subject)->data._FACTOR._comment) ) ;
				fdint( &((*subject)->data._FACTOR._visibility) ) ;
				fdident( &((*subject)->data._FACTOR._type) ) ;
				fdstring( &((*subject)->data._FACTOR._star) ) ;
				fdident( &((*subject)->data._FACTOR._field) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

factor *cpfactor( factor *subject ) {
	factor *result = calloc( 1, sizeof( struct factor_struct ) ) ;
	check_ptr( result, "calloc cpfactor" ) ;
	check_ptr( subject, "cpfactor" ) ;
	memcpy( result, subject, sizeof( struct factor_struct ) ) ;
	return result ;
}

void mvfactor( factor *subject, factor *object ) {
	check_ptr( subject, "mvfactor" ) ;
	check_ptr( object, "mvfactor" ) ;
	memcpy( object, subject, sizeof( struct factor_struct ) ) ;
}

void prfactor( int indent, factor *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == factor_BIND ) {
			printf( "factor_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case FACTOR:
				printf( "%s( ", nametable[FACTOR] ) ;
				printf( "comment=" ) ;
				prstring( indent+1, subject->data._FACTOR._comment ) ;
				printf( "," ) ;
				printf( "visibility=" ) ;
				print( indent+1, subject->data._FACTOR._visibility ) ;
				printf( "," ) ;
				printf( "type=" ) ;
				prident( indent+1, subject->data._FACTOR._type ) ;
				printf( "," ) ;
				printf( "star=" ) ;
				prstring( indent+1, subject->data._FACTOR._star ) ;
				printf( "," ) ;
				printf( "field=" ) ;
				prident( indent+1, subject->data._FACTOR._field ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void clfactor( factor *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != factor_BIND ) {
			switch( subject->tag ) {
			case FACTOR:
				clstring( subject->data._FACTOR._comment ) ;
				clint( subject->data._FACTOR._visibility ) ;
				clident( subject->data._FACTOR._type ) ;
				clstring( subject->data._FACTOR._star ) ;
				clident( subject->data._FACTOR._field ) ;
				break ;
			}
		}
	}
}

bool mtfactor( factor *pattern, factor *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == factor_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case FACTOR:
			return pattern->tag == subject->tag &&
				mtstring( pattern->data._FACTOR._comment, subject->data._FACTOR._comment ) &&
				mtint( pattern->data._FACTOR._visibility, subject->data._FACTOR._visibility ) &&
				mtident( pattern->data._FACTOR._type, subject->data._FACTOR._type ) &&
				mtstring( pattern->data._FACTOR._star, subject->data._FACTOR._star ) &&
				mtident( pattern->data._FACTOR._field, subject->data._FACTOR._field ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
factor_tag gtfactortag( factor *subject ) {
	check_ptr( subject, "gtfactortag" ) ;
	if( subject->tag == factor_BIND ) {
		fatal( 0, "gtfactortag" ) ;
	}
	return subject->tag ;
}
#endif

void stfactortag( factor *subject, factor_tag tag ) {
	check_ptr( subject, "stfactortag" ) ;
	if( tag == factor_BIND ) {
		fatal( 0, "stfactortag" ) ;
	}
	subject->tag = tag ;
}

void lffactor( factor *subject ) {
	check_ptr( subject, "lffactor" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

factor *mkFACTOR( string _comment, int _visibility, ident *_type, string _star, ident *_field ) { 
	factor *result = calloc( 1, sizeof( struct factor_struct ) ) ;
	check_ptr( result, "calloc mkFACTOR" ) ;
	result->tag = FACTOR ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._FACTOR._comment = _comment ;
	result->data._FACTOR._visibility = _visibility ;
	result->data._FACTOR._type = _type ;
	result->data._FACTOR._star = _star ;
	result->data._FACTOR._field = _field ;
	return result ;
}

factor *ptFACTOR( string _comment, int _visibility, ident *_type, string _star, ident *_field ) { 
	factor *result = calloc( 1, sizeof( struct factor_struct ) ) ;
	check_ptr( result, "calloc ptFACTOR" ) ;
	result->tag = FACTOR ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._FACTOR._comment = _comment ;
	result->data._FACTOR._visibility = _visibility ;
	result->data._FACTOR._type = _type ;
	result->data._FACTOR._star = _star ;
	result->data._FACTOR._field = _field ;
	return result ;
}

string *adFACTORcomment( factor *subject ) {
	check_tag( subject, FACTOR, "adFACTORcomment" ) ;
	return &subject->data._FACTOR._comment ;
}

#ifndef _FAST_
string gtFACTORcomment( factor *subject ) {
	check_tag( subject, FACTOR, "gtFACTORcomment" ) ;
	return subject->data._FACTOR._comment ;
}

#endif

void stFACTORcomment( factor *subject, string value ) {
	check_tag( subject, FACTOR, "stFACTORcomment" ) ;
	subject->data._FACTOR._comment = value ;
}

int *adFACTORvisibility( factor *subject ) {
	check_tag( subject, FACTOR, "adFACTORvisibility" ) ;
	return &subject->data._FACTOR._visibility ;
}

#ifndef _FAST_
int gtFACTORvisibility( factor *subject ) {
	check_tag( subject, FACTOR, "gtFACTORvisibility" ) ;
	return subject->data._FACTOR._visibility ;
}

#endif

void stFACTORvisibility( factor *subject, int value ) {
	check_tag( subject, FACTOR, "stFACTORvisibility" ) ;
	subject->data._FACTOR._visibility = value ;
}

ident **adFACTORtype( factor *subject ) {
	check_tag( subject, FACTOR, "adFACTORtype" ) ;
	return &subject->data._FACTOR._type ;
}

#ifndef _FAST_
ident *gtFACTORtype( factor *subject ) {
	check_tag( subject, FACTOR, "gtFACTORtype" ) ;
	return subject->data._FACTOR._type ;
}

#endif

void stFACTORtype( factor *subject, ident *value ) {
	check_tag( subject, FACTOR, "stFACTORtype" ) ;
	subject->data._FACTOR._type = value ;
}

string *adFACTORstar( factor *subject ) {
	check_tag( subject, FACTOR, "adFACTORstar" ) ;
	return &subject->data._FACTOR._star ;
}

#ifndef _FAST_
string gtFACTORstar( factor *subject ) {
	check_tag( subject, FACTOR, "gtFACTORstar" ) ;
	return subject->data._FACTOR._star ;
}

#endif

void stFACTORstar( factor *subject, string value ) {
	check_tag( subject, FACTOR, "stFACTORstar" ) ;
	subject->data._FACTOR._star = value ;
}

ident **adFACTORfield( factor *subject ) {
	check_tag( subject, FACTOR, "adFACTORfield" ) ;
	return &subject->data._FACTOR._field ;
}

#ifndef _FAST_
ident *gtFACTORfield( factor *subject ) {
	check_tag( subject, FACTOR, "gtFACTORfield" ) ;
	return subject->data._FACTOR._field ;
}

#endif

void stFACTORfield( factor *subject, ident *value ) {
	check_tag( subject, FACTOR, "stFACTORfield" ) ;
	subject->data._FACTOR._field = value ;
}

ident *bdident( ident **binding ) {
	ident *result = calloc( 1, sizeof( struct ident_struct ) ) ;
	check_ptr( result, "calloc bdident" ) ;
	result->tag = ident_BIND ;
	result->data._binding = binding ;
	result->flag = 0 ;
	return result ;
}

void frident( ident **subject ) {
	if( *subject != NULL ) {
		free( *subject ) ;
		*subject = NULL ;
	}
}

void fdident( ident **subject ) {
	if( *subject != NULL ) {
		if( (*subject)->tag != ident_BIND ) {
			switch( (*subject)->tag ) {
			case IDENT:
				fdstring( &((*subject)->data._IDENT._ident) ) ;
				break ;
			}
		}
		free( *subject ) ;
		*subject = NULL ;
	}
}

ident *cpident( ident *subject ) {
	ident *result = calloc( 1, sizeof( struct ident_struct ) ) ;
	check_ptr( result, "calloc cpident" ) ;
	check_ptr( subject, "cpident" ) ;
	memcpy( result, subject, sizeof( struct ident_struct ) ) ;
	return result ;
}

void mvident( ident *subject, ident *object ) {
	check_ptr( subject, "mvident" ) ;
	check_ptr( object, "mvident" ) ;
	memcpy( object, subject, sizeof( struct ident_struct ) ) ;
}

void prident( int indent, ident *subject ) {
	if( subject == NULL ) {
		printf( "NULL" ) ;
	} else if( subject->flag ) {
		printf( "@%d@", subject->flag ) ;
	} else {
		subject->flag = cnt++ ;
		printf( "\n%-3d: %*s", subject->flag, indent, "" ) ;
		if( subject->tag == ident_BIND ) {
			printf( "ident_BIND( %p )", (void*)subject->data._binding ) ;
		} else {
			switch( subject->tag ) {
			case IDENT:
				printf( "%s( ", nametable[IDENT] ) ;
				printf( "ident=" ) ;
				prstring( indent+1, subject->data._IDENT._ident ) ;
				printf( " )" ) ;
				break ;
			}
		}
	}
}

void clident( ident *subject ) {
	if( subject != NULL && subject->flag ) {
		subject->flag = 0 ;
		if( subject->tag != ident_BIND ) {
			switch( subject->tag ) {
			case IDENT:
				clstring( subject->data._IDENT._ident ) ;
				break ;
			}
		}
	}
}

bool mtident( ident *pattern, ident *subject ) {
	if( pattern == NULL ) {
		return True ;
	} else if( pattern->tag == ident_BIND ) {
		*( pattern->data._binding ) = subject ;
		return True ;
	} else if( subject == NULL ) {
		return False ;
	} else {
		switch( pattern->tag ) {
		case IDENT:
			return pattern->tag == subject->tag &&
				mtstring( pattern->data._IDENT._ident, subject->data._IDENT._ident ) ;
			break ;
		}
	}
	return False ;
}

#ifndef _FAST_
ident_tag gtidenttag( ident *subject ) {
	check_ptr( subject, "gtidenttag" ) ;
	if( subject->tag == ident_BIND ) {
		fatal( 0, "gtidenttag" ) ;
	}
	return subject->tag ;
}
#endif

void stidenttag( ident *subject, ident_tag tag ) {
	check_ptr( subject, "stidenttag" ) ;
	if( tag == ident_BIND ) {
		fatal( 0, "stidenttag" ) ;
	}
	subject->tag = tag ;
}

void lfident( ident *subject ) {
	check_ptr( subject, "lfident" ) ;
	if( subject->filename != NULL ) {
		lineno = subject->lineno ; 
		charno = subject->charno ; 
		filename=subject->filename ;
	}
}

ident *mkIDENT( string _ident ) { 
	ident *result = calloc( 1, sizeof( struct ident_struct ) ) ;
	check_ptr( result, "calloc mkIDENT" ) ;
	result->tag = IDENT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._IDENT._ident = _ident ;
	return result ;
}

ident *ptIDENT( string _ident ) { 
	ident *result = calloc( 1, sizeof( struct ident_struct ) ) ;
	check_ptr( result, "calloc ptIDENT" ) ;
	result->tag = IDENT ;
	result->flag = 0 ;
	result->lineno = lineno ;
	result->charno = charno ;
	result->filename = filename ;
	result->data._IDENT._ident = _ident ;
	return result ;
}

string *adIDENTident( ident *subject ) {
	check_tag( subject, IDENT, "adIDENTident" ) ;
	return &subject->data._IDENT._ident ;
}

#ifndef _FAST_
string gtIDENTident( ident *subject ) {
	check_tag( subject, IDENT, "gtIDENTident" ) ;
	return subject->data._IDENT._ident ;
}

#endif

void stIDENTident( ident *subject, string value ) {
	check_tag( subject, IDENT, "stIDENTident" ) ;
	subject->data._IDENT._ident = value ;
}

